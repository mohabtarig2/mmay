'use strict';Object.defineProperty(exports,'__esModule',{value:true});var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var lodash_throttle = throttle;function calculatePopupPosition(ref) {
  var windowDimensions = ref.windowDimensions;
  var popupDimensions = ref.popupDimensions;
  var mousePosition = ref.mousePosition;
  var safeMargin = ref.safeMargin;
  
  if(!safeMargin) { safeMargin = 0; }

  return {
    x: getX({
      windowWidth: windowDimensions.w, 
      popupWidth: popupDimensions.w, 
      mousePositionX: mousePosition.x, 
      safeMargin: safeMargin
    }),
    y: getY({
      windowHeight: windowDimensions.h, 
      popupHeight: popupDimensions.h, 
      mousePositionY: mousePosition.y, 
      safeMargin: safeMargin
    })
  }
}

function getX(ref) {
  var windowWidth = ref.windowWidth;
  var popupWidth = ref.popupWidth;
  var mousePositionX = ref.mousePositionX;
  var safeMargin = ref.safeMargin;

  if(isWindowEdgeOrOffscreen(mousePositionX)) { return safeMargin; }

  var popupHalfWidth = popupWidth / 2;
  var naiveXPosition = mousePositionX - popupHalfWidth;
  
  var popupRightEdge = naiveXPosition + popupWidth;
  var popupLeftEdge = naiveXPosition;
  
  if(isOffscreenLeft(popupLeftEdge, safeMargin)) {
    var missingWidth =  safeMargin - popupLeftEdge;
    return naiveXPosition + missingWidth;
  }

  if(isOffscreenRight(popupRightEdge, windowWidth)) {
    var excessWidth = popupRightEdge - windowWidth;
    return naiveXPosition - excessWidth - safeMargin;
  }

  return naiveXPosition;
}

function getY(ref) {
  var windowHeight = ref.windowHeight;
  var popupHeight = ref.popupHeight;
  var mousePositionY = ref.mousePositionY;
  var safeMargin = ref.safeMargin;

  if(isWindowEdgeOrOffscreen(mousePositionY)) { return safeMargin; }

  var popupHalfHeight = popupHeight / 2;
  var naiveYPosition = mousePositionY - popupHalfHeight;

  var popupTopEdge = naiveYPosition;
  if(isOffscreenTop(popupTopEdge, safeMargin)) {
    var missingHeight =  safeMargin - popupTopEdge;
    return naiveYPosition + missingHeight;
  }

  var popupBottomEdge = naiveYPosition + popupHeight;
  if(isOffscreenBottom(popupBottomEdge, windowHeight)) {
    var excessHeight = popupBottomEdge - windowHeight;
    return naiveYPosition - excessHeight - safeMargin;
  }

  return naiveYPosition;
}

var isWindowEdgeOrOffscreen = function (position) { return position < 1; };
var isOffscreenLeft   = function (popupLeftEdge, safeMargin) { return popupLeftEdge <= safeMargin; };
var isOffscreenRight  = function (popupRightEdge, windowWidth) { return popupRightEdge >= windowWidth; };
var isOffscreenTop    = function (popupTopEdge, safeMargin) { return popupTopEdge <= safeMargin; };
var isOffscreenBottom = function (popupBottomEdge, windowHeight) { return popupBottomEdge >= windowHeight; };//

var CLOSE_ANIMATION_DURATION_MS = 400; 
var MOUSE_LISTENER_THROTTLE_MS = 100;

function dialogWasClosed(newShowVal, oldShowVal) {
  return newShowVal === false && oldShowVal === true;
}

var script = {
  name: 'UnsavedChangesDialog',
  props: {
    show: {
      type: Boolean,
      required: true
    },
    title: {
      type: String,
      required: false,
      default: "Unsaved Changes",
    },
    subtitle: {
      type: String | Array,
      required: false,
      default: function () { return ["You have made changes.", "Do you want to save or discard them?"]; }
    }
  },
  data: function data() {
    var this$1 = this;

    return {
      position: {
        x: undefined,
        y: undefined
      },
      lastKnownMousePosition: {
        x: undefined,
        y: undefined
      },
      mouseClickListener:  lodash_throttle(function (e) {
        e = e || window.event;
        this$1.lastKnownMousePosition = { x: e.clientX, y: e.clientY };
        this$1.calculatePopupPosition();
        if(this$1.show) { this$1.deactivateMouseClickListener(); }
      }, MOUSE_LISTENER_THROTTLE_MS)
    }
  },
  mounted: function mounted() {    
    this.activateMouseClickListener();
    this.calculatePopupPosition();
    window.addEventListener('resize', this.handleWindowResize);
  },
  beforeDestroy: function beforeDestroy() {
    this.deactivateMouseClickListener();
    window.removeEventListener('resize', this.handleWindowResize);
  },
  methods: {
    activateMouseClickListener: function activateMouseClickListener() {
      document.addEventListener('click', this.mouseClickListener);
    },
    deactivateMouseClickListener: function deactivateMouseClickListener() {
      document.addEventListener('click', this.mouseClickListener);
    },
    handleWindowResize: function handleWindowResize() {
      this.calculatePopupPosition();
    },
    calculatePopupPosition: function calculatePopupPosition$1() {
      //if(!this.$refs.popupWrapper) return;
      this.position =  calculatePopupPosition({
        popupDimensions: {
          w: 287,//window.getComputedStyle(this.$refs.popupWrapper).getPropertyValue("width").replace("px", ""),
          h: 123//window.getComputedStyle(this.$refs.popupWrapper).getPropertyValue("height").replace("px", "")
        },
        windowDimensions: {
          w: window.innerWidth,
          h: window.innerHeight
        },
        mousePosition: {
          x: this.lastKnownMousePosition.x || this.windowCenterPoint.x,
          y: this.lastKnownMousePosition.y || this.windowCenterPoint.y
        },
        safeMargin: 30
      });
    }
  },
  computed: {
    windowCenterPoint: function windowCenterPoint() {
      return {
        x: window.innerWidth / 2,
        y: window.innerHeight /2
      }
    },
    positionStyle: function positionStyle() {
      return ("top:" + (this.position.y) + "px;left:" + (this.position.x) + "px;");
    },
    dynamicClasses: function dynamicClasses() {
      return this.show ? "" : "hide";
    }
  },
  watch: {
    show: function show(newVal, oldVal) {
      if(dialogWasClosed(newVal, oldVal)) {
        setTimeout(this.activateMouseClickListener, CLOSE_ANIMATION_DURATION_MS);
      }
    }
  }
};function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
        createInjectorSSR = createInjector;
        createInjector = shadowMode;
        shadowMode = false;
    }
    // Vue.extend constructor export interop.
    var options = typeof script === 'function' ? script.options : script;
    // render functions
    if (template && template.render) {
        options.render = template.render;
        options.staticRenderFns = template.staticRenderFns;
        options._compiled = true;
        // functional template
        if (isFunctionalTemplate) {
            options.functional = true;
        }
    }
    // scopedId
    if (scopeId) {
        options._scopeId = scopeId;
    }
    var hook;
    if (moduleIdentifier) {
        // server build
        hook = function (context) {
            // 2.3 injection
            context =
                context || // cached call
                    (this.$vnode && this.$vnode.ssrContext) || // stateful
                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
            // 2.2 with runInNewContext: true
            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                context = __VUE_SSR_CONTEXT__;
            }
            // inject component styles
            if (style) {
                style.call(this, createInjectorSSR(context));
            }
            // register component module identifier for async chunk inference
            if (context && context._registeredComponents) {
                context._registeredComponents.add(moduleIdentifier);
            }
        };
        // used by ssr in case component is cached and beforeCreate
        // never gets called
        options._ssrRegister = hook;
    }
    else if (style) {
        hook = shadowMode
            ? function (context) {
                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
            }
            : function (context) {
                style.call(this, createInjector(context));
            };
    }
    if (hook) {
        if (options.functional) {
            // register for functional component in vue file
            var originalRender = options.render;
            options.render = function renderWithStyleInjection(h, context) {
                hook.call(context);
                return originalRender(h, context);
            };
        }
        else {
            // inject component registration as beforeCreate hook
            var existing = options.beforeCreate;
            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
    }
    return script;
}function createInjectorSSR(context) {
    if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
    }
    if (!context)
        { return function () { }; }
    if (!('styles' in context)) {
        context._styles = context._styles || {};
        Object.defineProperty(context, 'styles', {
            enumerable: true,
            get: function () { return context._renderStyles(context._styles); }
        });
        context._renderStyles = context._renderStyles || renderStyles;
    }
    return function (id, style) { return addStyle(id, style, context); };
}
function addStyle(id, css, context) {
    var group =  css.media || 'default' ;
    var style = context._styles[group] || (context._styles[group] = { ids: [], css: '' });
    if (!style.ids.includes(id)) {
        style.media = css.media;
        style.ids.push(id);
        var code = css.source;
        style.css += code + '\n';
    }
}
function renderStyles(styles) {
    var css = '';
    for (var key in styles) {
        var style = styles[key];
        css +=
            '<style data-vue-ssr-id="' +
                Array.from(style.ids).join(' ') +
                '"' +
                (style.media ? ' media="' + style.media + '"' : '') +
                '>' +
                style.css +
                '</style>';
    }
    return css;
}/* script */
var __vue_script__ = script;

/* template */
var __vue_render__ = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"unsaved-changes-dialog"},[_vm._ssrNode("<div class=\"desktop-dialog--root\">","</div>",[_c('transition',{attrs:{"name":"fade-zoom"}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.show),expression:"show"}],staticClass:"desktop-dialog--wrapper",class:_vm.dynamicClasses,style:(_vm.positionStyle)},[_c('div',{staticClass:"text-section"},[_c('h1',[_vm._t("title",[_vm._v(_vm._s(_vm.title))])],2),_vm._v(" "),_vm._l((_vm.subtitle),function(str,idx){return _c('p',{key:idx},[_vm._v(_vm._s(str))])}),_vm._v(" "),_vm._t("body")],2),_vm._v(" "),_c('div',{staticClass:"button-row"},[_c('button',{on:{"click":function($event){$event.stopPropagation();return _vm.$emit('cancel')}}},[_vm._t("cancel-button",[_vm._v("Cancel")])],2),_vm._v(" "),_c('button',{staticClass:"button-danger",on:{"click":function($event){$event.stopPropagation();return _vm.$emit('discard')}}},[_vm._t("discard-button",[_vm._v("Discard")])],2),_vm._v(" "),_c('button',{staticClass:"button-success",on:{"click":function($event){$event.stopPropagation();return _vm.$emit('save')}}},[_vm._t("save-button",[_vm._v("Save")])],2)])])])],1),_vm._ssrNode(" "),_vm._ssrNode("<div class=\"mobile-dialog--root\">","</div>",[_c('transition',{attrs:{"name":"mobile-animate"}},[(_vm.show)?_c('div',{staticClass:"mobile-dialog--wrapper",class:_vm.dynamicClasses},[_c('div',{staticClass:"text-section"},[_c('h1',[_vm._t("title",[_vm._v(_vm._s(_vm.title))])],2),_vm._v(" "),_vm._l((_vm.subtitle),function(str,idx){return _c('p',{key:idx},[_vm._v(_vm._s(str))])}),_vm._v(" "),_vm._t("body")],2),_vm._v(" "),_c('div',{staticClass:"button-row"},[_c('button',{staticClass:"button-success",on:{"click":function($event){$event.stopPropagation();return _vm.$emit('save')}}},[_vm._t("save-button",[_vm._v("Save")])],2),_vm._v(" "),_c('button',{staticClass:"button-danger",on:{"click":function($event){$event.stopPropagation();return _vm.$emit('discard')}}},[_vm._t("discard-button",[_vm._v("Discard")])],2)])]):_vm._e()]),_vm._ssrNode(" "),_c('transition',{attrs:{"name":"mobile-animate"}},[(_vm.show)?_c('div',{staticClass:"mobile-dialog--cancel-button"},[_c('button',{on:{"click":function($event){$event.stopPropagation();return _vm.$emit('cancel')}}},[_vm._t("cancel-button",[_vm._v("Cancel")])],2)]):_vm._e()])],2),_vm._ssrNode(" "),_c('transition',{attrs:{"name":"fade"}},[(_vm.show)?_c('div',{staticClass:"unsaved-changes-dialog--background-overlay",on:{"click":function($event){$event.stopPropagation();return _vm.$emit('cancel')}}}):_vm._e()])],2)};
var __vue_staticRenderFns__ = [];

  /* style */
  var __vue_inject_styles__ = function (inject) {
    if (!inject) { return }
    inject("data-v-27b92843_0", { source: "@media screen and (min-width:600px){.unsaved-changes-dialog .desktop-dialog--root{display:block}.unsaved-changes-dialog .mobile-dialog--root{display:none}}@media screen and (max-width:599px){.unsaved-changes-dialog .desktop-dialog--root{display:none}.unsaved-changes-dialog .mobile-dialog--root{display:block}}.unsaved-changes-dialog{font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen,Ubuntu,Cantarell,\"Open Sans\",\"Helvetica Neue\",sans-serif}.unsaved-changes-dialog.hide{opacity:0}.unsaved-changes-dialog .text-section{margin-top:16px;padding-bottom:8px;margin-bottom:4px;text-align:center}.unsaved-changes-dialog h1{font-size:.9rem;color:#aaaeb3;text-transform:uppercase;font-weight:400;letter-spacing:.2px;margin-bottom:8px}.unsaved-changes-dialog p{transform:translateZ(0);margin:0;line-height:1.2rem;font-size:.9rem}.unsaved-changes-dialog .button-row{border-top:1px solid #edeeef;display:flex}.unsaved-changes-dialog button{width:100%;font-weight:600;padding:8px 0 8px 0;border-radius:0;color:#fff;font-size:.9rem;font-weight:600;border:none;text-decoration:none;transition:all .3s cubic-bezier(.165,.84,.44,1);white-space:nowrap;height:fit-content;background:0 0;color:#000}.unsaved-changes-dialog button:hover{background:#e0e1e3}.unsaved-changes-dialog button:active{background:#d2d4d7}.unsaved-changes-dialog button.button-danger{color:#ce0b24}.unsaved-changes-dialog button.button-danger:hover{background:#ce0b24;color:#fff}.unsaved-changes-dialog button.button-danger:active{background:#b60a20;color:#fff}.unsaved-changes-dialog button.button-success{color:#3bb26d}.unsaved-changes-dialog button.button-success:hover{background:#3bb26d;color:#fff}.unsaved-changes-dialog button.button-success:active{background:#359f61;color:#fff}.unsaved-changes-dialog .mobile-dialog--root button{padding:12px 0}.unsaved-changes-dialog .mobile-dialog--root button:not(:last-of-type){border-bottom:1px solid #edeeef}.unsaved-changes-dialog .mobile-dialog--root button:last-of-type{border-radius:0 0 8px 8px}.unsaved-changes-dialog .mobile-dialog--root button:only-child{border-radius:8px}.unsaved-changes-dialog .mobile-dialog--wrapper{z-index:6;position:fixed;width:95%;top:50%;left:50%;transform:translateX(-50%) translateY(-50%);background:#fff;border-radius:8px;box-shadow:0 4px 10px rgba(0,0,0,.418)}.unsaved-changes-dialog .mobile-dialog--wrapper .button-row{flex-direction:column}.unsaved-changes-dialog .mobile-dialog--cancel-button{position:fixed;bottom:8px;width:95%;z-index:6;background:#fff;border-radius:8px;box-shadow:0 4px 10px rgba(0,0,0,.418);left:50%;transform:translateX(-50%)}.unsaved-changes-dialog .desktop-dialog--wrapper{z-index:6;position:fixed;width:18rem;height:fit-content;background:#fff;border-radius:8px;box-shadow:0 4px 10px rgba(0,0,0,.418)}.unsaved-changes-dialog .desktop-dialog--wrapper .button-row{flex-direction:row;justify-items:space-between;width:100%}.unsaved-changes-dialog .desktop-dialog--wrapper button:first-of-type{border-bottom-left-radius:8px;border-right:1px solid #edeeef}.unsaved-changes-dialog .desktop-dialog--wrapper button:last-of-type{border-bottom-right-radius:8px;border-left:1px solid #edeeef}.fade-zoom-enter-active{animation:fade-zoom .4s cubic-bezier(.165,.84,.44,1)}.fade-zoom-leave-active{animation:fade-zoom .15s ease-in reverse}@keyframes fade-zoom{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}.mobile-dialog--wrapper.mobile-animate-enter-active{animation:fade-zoom-autocenter-animation .4s cubic-bezier(.165,.84,.44,1)}.mobile-dialog--wrapper.mobile-animate-leave-active{animation:reverse fade-zoom-autocenter-animation .15s cubic-bezier(.165,.84,.44,1)}@keyframes fade-zoom-autocenter-animation{0%{opacity:0;transform:translateX(-50%) translateY(-50%) scale(.9)}100%{opacity:1;transform:translateX(-50%) translateY(-50%) scale(1)}}.mobile-dialog--cancel-button.mobile-animate-enter-active{animation:.4s close-button-animation cubic-bezier(.165,.84,.44,1)}.mobile-dialog--cancel-button.mobile-animate-leave-active{animation:reverse .15s close-button-animation cubic-bezier(.165,.84,.44,1)}@keyframes close-button-animation{0%{opacity:0;transform:translateX(-50%) translateY(50px)}100%{opacity:1;transform:translateX(-50%) translateY(0)}}.unsaved-changes-dialog--background-overlay{position:fixed;z-index:5;left:0;top:0;width:100%;height:100%;overflow:hidden;background:rgba(0,0,0,.7)}.fade-enter-active{animation:fade .4s cubic-bezier(.165,.84,.44,1)}.fade-leave-active{animation:fade .3s ease-in reverse}@keyframes fade{0%{opacity:0}100%{opacity:1}}", map: undefined, media: undefined });

  };
  /* scoped */
  var __vue_scope_id__ = undefined;
  /* module identifier */
  var __vue_module_identifier__ = "data-v-27b92843";
  /* functional template */
  var __vue_is_functional_template__ = false;
  /* style inject shadow dom */
  

  
  var __vue_component__ = normalizeComponent(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    false,
    undefined,
    createInjectorSSR,
    undefined
  );// Import vue component

// install function executed by Vue.use()
function install(Vue) {
  if (install.installed) { return; }
  install.installed = true;
  Vue.component('VueUnsavedChangesDialog', __vue_component__);
}

// Create module definition for Vue.use()
var plugin = {
  install: install,
};

// To auto-install when vue is found
/* global window global */
var GlobalVue = null;
if (typeof window !== 'undefined') {
  GlobalVue = window.Vue;
} else if (typeof global !== 'undefined') {
  GlobalVue = global.Vue;
}
if (GlobalVue) {
  GlobalVue.use(plugin);
}

// Inject install function into component - allows component
// to be registered via Vue.use() as well as Vue.component()
__vue_component__.install = install;

// It's possible to expose named exports when writing components that can
// also be used as directives, etc. - eg. import { RollupDemoDirective } from 'rollup-demo';
// export const RollupDemoDirective = component;
exports.default=__vue_component__;